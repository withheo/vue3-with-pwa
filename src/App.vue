<template>
  <div>
    <div class = 'wrapper'>
      PWA 로 작성한 vue3 페이지입니다. (5초로수정) v2
      <button class="btn-large" @click.stop="onAllowNotification"> 알림 허용 </button>
      <button class="btn-large" @click.stop="onFingerPrint"> 인식 </button>
      
      <div class = "box">
        notificationStr: {{ state.notificationStr }}
      </div>
      <div class = "box">
         {{ state.keyStr }}
      </div>

      <div class = "box">
         {{ state.workerStateStr }}
      </div>

      <div class = "box">
        메세지 보내냄:{{ state.msg }}
      </div>

      <div class = "box"> notiPermission : {{ state.notiPermission }}</div>
      <div class = "box"> workerState : {{ state.workerState }}</div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, onMounted, reactive } from 'vue';

// import HelloWorld from './components/HelloWorld.vue';

export default defineComponent({
  name: 'App',
  components: {
    
  },
  setup() {

    const state = reactive({
      keyStr: "",
      notificationStr : "",
      workerStateStr: "",
      msg: "",
      notiPermission : "",
      workerState: "",
    })
    const initWebPushWorker = () => {
      if('serviceWorker' in navigator) {
        navigator.serviceWorker
          .register('./pushServiceWorker.js')
          .then(() => {
              state.workerStateStr = 'Service worker registered!';
              console.log('Service worker registered!');

              state.notiPermission = Notification.permission;
              navigator.serviceWorker.addEventListener('statechange', function(e: any) {
                state.workerState = e.target.state;
              });
          })
          .catch( err => {
            state.workerStateStr = err;
            console.log(err);
          });
      }
    } 

    const onFingerPrint = () => {
      if (!window.PublicKeyCredential) {
        /* Client not capable. Handle error. */
      }

      const publicKey: any = {
        // The challenge is produced by the server; see the Security Considerations
        challenge: new Uint8Array([
          21,
          31,
          105 /* 29 more random bytes generated by the server */
        ]),

        // Relying Party:
        rp: {
          name: "ACME Corporation"
        },

        // User:
        user: {
          id: Uint8Array.from(
            window.atob("MIIBkzCCATigAwIBAjCCAZMwggE4oAMCAQIwggGTMII="),
            c => c.charCodeAt(0)
          ),
          name: "mynet81@gmail.com",
          displayName: "Alex P. Müller"
        },

        // This Relying Party will accept either an ES256 or RS256 credential, but
        // prefers an ES256 credential.
        pubKeyCredParams: [
          {
            type: "public-key",
            alg: -7 // "ES256" as registered in the IANA COSE Algorithms registry
          },
          {
            type: "public-key",
            alg: -257 // Value registered by this specification for "RS256"
          }
        ],

        authenticatorSelection: {
          // Try to use UV if possible. This is also the default.
          userVerification: "preferred"
        },

        timeout: 360000, // 6 minutes
        excludeCredentials: [], // No exclude list of PKCredDescriptors
        extensions: { loc: true } // Include location information
        // in attestation
      };

      // Note: The following call will cause the authenticator to display UI.
      navigator.credentials
        .create({ publicKey })
        // eslint-disable-next-line no-unused-vars
        .then((newCredentialInfo: any) => {
          // Send new credential info to server for verification and registration.
          // eslint-disable-next-line no-unused-vars, no-undef
          
          // eslint-disable-next-line no-undef
          console.log("save", newCredentialInfo);
          state.keyStr = newCredentialInfo;
        })
        .catch(() => {
          // No acceptable authenticator or user refused consent. Handle appropriately.

          console.log("fail");
          state.keyStr = " Fail";
        });
    }

    const onAllowNotification = () => {
      if (!("Notification" in window)) {
        state.notificationStr = "This browser does not support notifications.";
      } 
      Notification.requestPermission().then((result) => {
        state.notificationStr = result;
        if (result === "granted") {
          //randomNotification();
          randomNotification2();
        }
      });
    }
    let msgCnt = 0;
    const randomNotification2 = () => {
      try{

         
            state.msg = msgCnt + " : 보내기 전2 > ";
            console.log(navigator.serviceWorker);
            navigator.serviceWorker.getRegistrations().then((registration) => {
              setTimeout(() => {
                state.msg = msgCnt + " : 보내기 전3 > ";
                registration[0].showNotification("TEST Notification", {
                  body: "Hello",
                });
                state.msg = msgCnt + " : 보내기 전4 > ";
              },3000)
            });
         
      }catch(e: any) {
        state.msg = msgCnt + " : 보내기 에러 " + e.getMessage();
      }
    }

    const randomNotification = () => {
      try{
        const notifTitle = "info";
        const options = {
          body: "notification Test ",
        };
        state.msg = msgCnt + " : 보내기 전 > " + options.body;
        const notification = new Notification(notifTitle, options);
        state.msg = msgCnt + " : 보내기 후 > " + options.body + notification;
        // setTimeout(randomNotification, 5000);
      }catch(e: any) {
        state.msg = msgCnt + " : 보내기 에러 " + e.getMessage();
      }
    }

    onMounted(() => {
      initWebPushWorker();
      console.log(randomNotification);
    })

    return {
      onFingerPrint,
      onAllowNotification,
      state
    }
  }
});
</script>

<style>
.wrapper {
  display: flex;
  flex-direction: column;
  width : 100%;
  height: 100%;
  align-items: center;
  justify-content: center;
}
.btn-large {
  width: 200px;
  height: 50px;
  border-radius: 10px;
  cursor: pointer;
  margin-top:4rem;
}
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 50px;
}

.box {
  padding: 10px;
}
</style>
