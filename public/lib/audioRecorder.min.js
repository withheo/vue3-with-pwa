///////////////////////////////////////////////////
// KiwiVoiceRecorder                             //
// https://www.kiwisoft.kr                       //
// Copyright © 앤아이비디앤. All rights reserved. //
///////////////////////////////////////////////////
!function(t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.AudioRecorder = e() : t.AudioRecorder = e()
}(self, (()=>(()=>{
  "use strict";
  var t = {
      d: (e,r)=>{
          for (var o in r)
              t.o(r, o) && !t.o(e, o) && Object.defineProperty(e, o, {
                  enumerable: !0,
                  get: r[o]
              })
      }
      ,
      o: (t,e)=>Object.prototype.hasOwnProperty.call(t, e)
  }
    , e = {};
  function r(t) {
      return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
          return typeof t
      }
      : function(t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      }
      ,
      r(t)
  }
  function o(t, e) {
      for (var o = 0; o < e.length; o++) {
          var n = e[o];
          n.enumerable = n.enumerable || !1,
          n.configurable = !0,
          "value"in n && (n.writable = !0),
          Object.defineProperty(t, (void 0,
          i = function(t, e) {
              if ("object" !== r(t) || null === t)
                  return t;
              var o = t[Symbol.toPrimitive];
              if (void 0 !== o) {
                  var n = o.call(t, "string");
                  if ("object" !== r(n))
                      return n;
                  throw new TypeError("@@toPrimitive must return a primitive value.")
              }
              return String(t)
          }(n.key),
          "symbol" === r(i) ? i : String(i)), n)
      }
      var i
  }
  function n(t, e) {
      (null == e || e > t.length) && (e = t.length);
      for (var r = 0, o = new Array(e); r < e; r++)
          o[r] = t[r];
      return o
  }
  t.d(e, {
      default: ()=>C
  });
  var i = null
    , a = 0
    , s = []
    , u = {};
  function c(t) {
    console.log(t);
      a = t;
      var e, r = function(t, e) {
          var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
          if (!r) {
              if (Array.isArray(t) || (r = function(t, e) {
                  if (t) {
                      if ("string" == typeof t)
                          return n(t, e);
                      var r = Object.prototype.toString.call(t).slice(8, -1);
                      return "Object" === r && t.constructor && (r = t.constructor.name),
                      "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n(t, e) : void 0
                  }
              }(t)) || e && t && "number" == typeof t.length) {
                  r && (t = r);
                  var o = 0
                    , i = function() {};
                  return {
                      s: i,
                      n: function() {
                          return o >= t.length ? {
                              done: !0
                          } : {
                              done: !1,
                              value: t[o++]
                          }
                      },
                      e: function(t) {
                          throw t
                      },
                      f: i
                  }
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
          }
          var a, s = !0, u = !1;
          console.log(r);
          return {
              s: function() {
                  r = r.call(t)
              },
              n: function() {
                  var t = r.next();
                  return s = t.done,
                  t
              },
              e: function(t) {
                  u = !0,
                  a = t
              },
              f: function() {
                  try {
                      s || null == r.return || r.return()
                  } finally {
                      if (u)
                          throw a
                  }
              }
          }
      }(s);
      try {
          for (r.s(); !(e = r.n()).done; )
              (0,
              e.value)()
      } catch (t) {
          r.e(t)
      } finally {
          r.f()
      }
      s = []
  }
  function l(t) {
      var e;
      console.error("woerere init ", t);
      // t = './lib/mp3lib.min.js';
      /^https?:\/\//.test(t) && (e = 'importScripts("'.concat(t, '");'),
      t = URL.createObjectURL(new Blob([e],{
          type: "text/javascript"
      }))),
      
      //t = './lib/mp3lib.min.js',
      i = new Worker(t),
      a = 1,
      i.onmessage = function(t) {
        console.log("meeesage :", t.data)
          switch (t.data.message) {
            
          case "ready":
            console.log(c);
              c(2);
              break;
          case "data":
              t.data.jobId in u && u[t.data.jobId].ondataavailable(t.data.data);
              break;
          case "stopped":
              t.data.jobId in u && u[t.data.jobId].onstopped()
          }
      }
      ,
      i.onerror = function(t) {
          console.error("mp3worker error event", t),
          c(3)
      }
  }
  var f = function() {
      function t(e) {
          var r = this;
          !function(t, e) {
              if (!(t instanceof e))
                  throw new TypeError("Cannot call a class as a function")
          }(this, t),
          this.jobId = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (function(t) {
              return (t ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t / 4).toString(16)
          }
          )),
          this.options = e,
          u[this.jobId] = {
              ondataavailable: function(t) {
                  r.ondataavailable && r.ondataavailable(t)
              },
              onstopped: function() {
                  delete u[r.jobId],
                  r.onstopped && r.onstopped()
              }
          }
      }
      var e, r, n;
      return e = t,
      n = [{
          key: "preload",
          value: function(t) {
              0 != a && 3 != a || l(t)
          }
      }, {
          key: "waitForWorker",
          value: function(t) {
              return 2 == a ? Promise.resolve() : (0 != a && 3 != a || l(t),
              new Promise((function(t, e) {
                  s.push((function() {
                      if (2 == a)
                          t();
                      else {
                          var r = new Error("MP3 worker failed");
                          r.name = "WorkerError",
                          e(r)
                      }
                  }
                  ))
              }
              )))
          }
      }],
      (r = [{
          key: "start",
          value: function() {
              console.error(" start call" , this , i)
              i.postMessage({
                  command: "start",
                  jobId: this.jobId,
                  options: this.options
              })
          }
      }, {
          key: "sendData",
          value: function(t) {
              t && t.length > 0 && t[0].length > 0 && i.postMessage({
                  command: "data",
                  jobId: this.jobId,
                  buffers: t
              })
          }
      }, {
          key: "stop",
          value: function() {
            console.error(" end call")
              i.postMessage({
                  command: "stop",
                  jobId: this.jobId
              })
          }
      }]) && o(e.prototype, r),
      n && o(e, n),
      Object.defineProperty(e, "prototype", {
          writable: !1
      }),
      t
  }();
  function h(t) {
      return h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
          return typeof t
      }
      : function(t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      }
      ,
      h(t)
  }
  function p(t, e) {
      for (var r = 0; r < e.length; r++) {
          var o = e[r];
          o.enumerable = o.enumerable || !1,
          o.configurable = !0,
          "value"in o && (o.writable = !0),
          Object.defineProperty(t, (void 0,
          n = function(t, e) {
              if ("object" !== h(t) || null === t)
                  return t;
              var r = t[Symbol.toPrimitive];
              if (void 0 !== r) {
                  var o = r.call(t, "string");
                  if ("object" !== h(o))
                      return o;
                  throw new TypeError("@@toPrimitive must return a primitive value.")
              }
              return String(t)
          }(o.key),
          "symbol" === h(n) ? n : String(n)), o)
      }
      var n
  }
  var d = function() {
      function t() {
          !function(t, e) {
              if (!(t instanceof e))
                  throw new TypeError("Cannot call a class as a function")
          }(this, t),
          this.reset()
      }
      var e, r;
      return e = t,
      (r = [{
          key: "reset",
          value: function() {
              this.startTime = null,
              this.stoppedTime = null
          }
      }, {
          key: "start",
          value: function() {
              this.startTime || (this.startTime = Date.now()),
              this.stoppedTime && (this.startTime += Date.now() - this.stoppedTime,
              this.stoppedTime = null)
          }
      }, {
          key: "resetAndStart",
          value: function() {
              this.reset(),
              this.start()
          }
      }, {
          key: "stop",
          value: function() {
              this.stoppedTime || (this.stoppedTime = Date.now())
          }
      }, {
          key: "getTime",
          value: function() {
              return this.startTime ? this.stoppedTime ? this.stoppedTime - this.startTime : Date.now() - this.startTime : 0
          }
      }]) && p(e.prototype, r),
      Object.defineProperty(e, "prototype", {
          writable: !1
      }),
      t
  }();
  function v(t) {
      return v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
          return typeof t
      }
      : function(t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      }
      ,
      v(t)
  }
  function y() {
      y = function() {
          return t
      }
      ;
      var t = {}
        , e = Object.prototype
        , r = e.hasOwnProperty
        , o = Object.defineProperty || function(t, e, r) {
          t[e] = r.value
      }
        , n = "function" == typeof Symbol ? Symbol : {}
        , i = n.iterator || "@@iterator"
        , a = n.asyncIterator || "@@asyncIterator"
        , s = n.toStringTag || "@@toStringTag";
      function u(t, e, r) {
          return Object.defineProperty(t, e, {
              value: r,
              enumerable: !0,
              configurable: !0,
              writable: !0
          }),
          t[e]
      }
      try {
          u({}, "")
      } catch (t) {
          u = function(t, e, r) {
              return t[e] = r
          }
      }
      function c(t, e, r, n) {
          var i = e && e.prototype instanceof h ? e : h
            , a = Object.create(i.prototype)
            , s = new E(n || []);
          return o(a, "_invoke", {
              value: S(t, r, s)
          }),
          a
      }
      function l(t, e, r) {
          try {
              return {
                  type: "normal",
                  arg: t.call(e, r)
              }
          } catch (t) {
              return {
                  type: "throw",
                  arg: t
              }
          }
      }
      t.wrap = c;
      var f = {};
      function h() {}
      function p() {}
      function d() {}
      var m = {};
      u(m, i, (function() {
          return this
      }
      ));
      var g = Object.getPrototypeOf
        , b = g && g(g(N([])));
      b && b !== e && r.call(b, i) && (m = b);
      var w = d.prototype = h.prototype = Object.create(m);
      function k(t) {
          ["next", "throw", "return"].forEach((function(e) {
              u(t, e, (function(t) {
                  return this._invoke(e, t)
              }
              ))
          }
          ))
      }
      function j(t, e) {
          function n(o, i, a, s) {
              var u = l(t[o], t, i);
              if ("throw" !== u.type) {
                  var c = u.arg
                    , f = c.value;
                  return f && "object" == v(f) && r.call(f, "__await") ? e.resolve(f.__await).then((function(t) {
                      n("next", t, a, s)
                  }
                  ), (function(t) {
                      n("throw", t, a, s)
                  }
                  )) : e.resolve(f).then((function(t) {
                      c.value = t,
                      a(c)
                  }
                  ), (function(t) {
                      return n("throw", t, a, s)
                  }
                  ))
              }
              s(u.arg)
          }
          var i;
          o(this, "_invoke", {
              value: function(t, r) {
                  function o() {
                      return new e((function(e, o) {
                          n(t, r, e, o)
                      }
                      ))
                  }
                  return i = i ? i.then(o, o) : o()
              }
          })
      }
      function S(t, e, r) {
          var o = "suspendedStart";
          return function(n, i) {
              if ("executing" === o)
                  throw new Error("Generator is already running");
              if ("completed" === o) {
                  if ("throw" === n)
                      throw i;
                  return {
                      value: void 0,
                      done: !0
                  }
              }
              for (r.method = n,
              r.arg = i; ; ) {
                  var a = r.delegate;
                  if (a) {
                      var s = x(a, r);
                      if (s) {
                          if (s === f)
                              continue;
                          return s
                      }
                  }
                  if ("next" === r.method)
                      r.sent = r._sent = r.arg;
                  else if ("throw" === r.method) {
                      if ("suspendedStart" === o)
                          throw o = "completed",
                          r.arg;
                      r.dispatchException(r.arg)
                  } else
                      "return" === r.method && r.abrupt("return", r.arg);
                  o = "executing";
                  var u = l(t, e, r);
                  if ("normal" === u.type) {
                      if (o = r.done ? "completed" : "suspendedYield",
                      u.arg === f)
                          continue;
                      return {
                          value: u.arg,
                          done: r.done
                      }
                  }
                  "throw" === u.type && (o = "completed",
                  r.method = "throw",
                  r.arg = u.arg)
              }
          }
      }
      function x(t, e) {
          var r = e.method
            , o = t.iterator[r];
          if (void 0 === o)
              return e.delegate = null,
              "throw" === r && t.iterator.return && (e.method = "return",
              e.arg = void 0,
              x(t, e),
              "throw" === e.method) || "return" !== r && (e.method = "throw",
              e.arg = new TypeError("The iterator does not provide a '" + r + "' method")),
              f;
          var n = l(o, t.iterator, e.arg);
          if ("throw" === n.type)
              return e.method = "throw",
              e.arg = n.arg,
              e.delegate = null,
              f;
          var i = n.arg;
          return i ? i.done ? (e[t.resultName] = i.value,
          e.next = t.nextLoc,
          "return" !== e.method && (e.method = "next",
          e.arg = void 0),
          e.delegate = null,
          f) : i : (e.method = "throw",
          e.arg = new TypeError("iterator result is not an object"),
          e.delegate = null,
          f)
      }
      function P(t) {
          var e = {
              tryLoc: t[0]
          };
          1 in t && (e.catchLoc = t[1]),
          2 in t && (e.finallyLoc = t[2],
          e.afterLoc = t[3]),
          this.tryEntries.push(e)
      }
      function O(t) {
          var e = t.completion || {};
          e.type = "normal",
          delete e.arg,
          t.completion = e
      }
      function E(t) {
          this.tryEntries = [{
              tryLoc: "root"
          }],
          t.forEach(P, this),
          this.reset(!0)
      }
      function N(t) {
          if (t) {
              var e = t[i];
              if (e)
                  return e.call(t);
              if ("function" == typeof t.next)
                  return t;
              if (!isNaN(t.length)) {
                  var o = -1
                    , n = function e() {
                      for (; ++o < t.length; )
                          if (r.call(t, o))
                              return e.value = t[o],
                              e.done = !1,
                              e;
                      return e.value = void 0,
                      e.done = !0,
                      e
                  };
                  return n.next = n
              }
          }
          return {
              next: A
          }
      }
      function A() {
          return {
              value: void 0,
              done: !0
          }
      }
      return p.prototype = d,
      o(w, "constructor", {
          value: d,
          configurable: !0
      }),
      o(d, "constructor", {
          value: p,
          configurable: !0
      }),
      p.displayName = u(d, s, "GeneratorFunction"),
      t.isGeneratorFunction = function(t) {
          var e = "function" == typeof t && t.constructor;
          return !!e && (e === p || "GeneratorFunction" === (e.displayName || e.name))
      }
      ,
      t.mark = function(t) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(t, d) : (t.__proto__ = d,
          u(t, s, "GeneratorFunction")),
          t.prototype = Object.create(w),
          t
      }
      ,
      t.awrap = function(t) {
          return {
              __await: t
          }
      }
      ,
      k(j.prototype),
      u(j.prototype, a, (function() {
          return this
      }
      )),
      t.AsyncIterator = j,
      t.async = function(e, r, o, n, i) {
          void 0 === i && (i = Promise);
          var a = new j(c(e, r, o, n),i);
          return t.isGeneratorFunction(r) ? a : a.next().then((function(t) {
              return t.done ? t.value : a.next()
          }
          ))
      }
      ,
      k(w),
      u(w, s, "Generator"),
      u(w, i, (function() {
          return this
      }
      )),
      u(w, "toString", (function() {
          return "[object Generator]"
      }
      )),
      t.keys = function(t) {
          var e = Object(t)
            , r = [];
          for (var o in e)
              r.push(o);
          return r.reverse(),
          function t() {
              for (; r.length; ) {
                  var o = r.pop();
                  if (o in e)
                      return t.value = o,
                      t.done = !1,
                      t
              }
              return t.done = !0,
              t
          }
      }
      ,
      t.values = N,
      E.prototype = {
          constructor: E,
          reset: function(t) {
              if (this.prev = 0,
              this.next = 0,
              this.sent = this._sent = void 0,
              this.done = !1,
              this.delegate = null,
              this.method = "next",
              this.arg = void 0,
              this.tryEntries.forEach(O),
              !t)
                  for (var e in this)
                      "t" === e.charAt(0) && r.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = void 0)
          },
          stop: function() {
              this.done = !0;
              var t = this.tryEntries[0].completion;
              if ("throw" === t.type)
                  throw t.arg;
              return this.rval
          },
          dispatchException: function(t) {
              if (this.done)
                  throw t;
              var e = this;
              function o(r, o) {
                  return a.type = "throw",
                  a.arg = t,
                  e.next = r,
                  o && (e.method = "next",
                  e.arg = void 0),
                  !!o
              }
              for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                  var i = this.tryEntries[n]
                    , a = i.completion;
                  if ("root" === i.tryLoc)
                      return o("end");
                  if (i.tryLoc <= this.prev) {
                      var s = r.call(i, "catchLoc")
                        , u = r.call(i, "finallyLoc");
                      if (s && u) {
                          if (this.prev < i.catchLoc)
                              return o(i.catchLoc, !0);
                          if (this.prev < i.finallyLoc)
                              return o(i.finallyLoc)
                      } else if (s) {
                          if (this.prev < i.catchLoc)
                              return o(i.catchLoc, !0)
                      } else {
                          if (!u)
                              throw new Error("try statement without catch or finally");
                          if (this.prev < i.finallyLoc)
                              return o(i.finallyLoc)
                      }
                  }
              }
          },
          abrupt: function(t, e) {
              for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                  var n = this.tryEntries[o];
                  if (n.tryLoc <= this.prev && r.call(n, "finallyLoc") && this.prev < n.finallyLoc) {
                      var i = n;
                      break
                  }
              }
              i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
              var a = i ? i.completion : {};
              return a.type = t,
              a.arg = e,
              i ? (this.method = "next",
              this.next = i.finallyLoc,
              f) : this.complete(a)
          },
          complete: function(t, e) {
              if ("throw" === t.type)
                  throw t.arg;
              return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg,
              this.method = "return",
              this.next = "end") : "normal" === t.type && e && (this.next = e),
              f
          },
          finish: function(t) {
              for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                  var r = this.tryEntries[e];
                  if (r.finallyLoc === t)
                      return this.complete(r.completion, r.afterLoc),
                      O(r),
                      f
              }
          },
          catch: function(t) {
              for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                  var r = this.tryEntries[e];
                  if (r.tryLoc === t) {
                      var o = r.completion;
                      if ("throw" === o.type) {
                          var n = o.arg;
                          O(r)
                      }
                      return n
                  }
              }
              throw new Error("illegal catch attempt")
          },
          delegateYield: function(t, e, r) {
              return this.delegate = {
                  iterator: N(t),
                  resultName: e,
                  nextLoc: r
              },
              "next" === this.method && (this.arg = void 0),
              f
          }
      },
      t
  }
  function m(t, e, r, o, n, i, a) {
      try {
          var s = t[i](a)
            , u = s.value
      } catch (t) {
          return void r(t)
      }
      s.done ? e(u) : Promise.resolve(u).then(o, n)
  }
  function g(t) {
      return function() {
          var e = this
            , r = arguments;
          return new Promise((function(o, n) {
              var i = t.apply(e, r);
              function a(t) {
                  m(i, o, n, a, s, "next", t)
              }
              function s(t) {
                  m(i, o, n, a, s, "throw", t)
              }
              a(void 0)
          }
          ))
      }
  }
  function b(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(t);
          e && (o = o.filter((function(e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable
          }
          ))),
          r.push.apply(r, o)
      }
      return r
  }
  function w(t) {
      for (var e = 1; e < arguments.length; e++) {
          var r = null != arguments[e] ? arguments[e] : {};
          e % 2 ? b(Object(r), !0).forEach((function(e) {
              k(t, e, r[e])
          }
          )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : b(Object(r)).forEach((function(e) {
              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e))
          }
          ))
      }
      return t
  }
  function k(t, e, r) {
      return (e = S(e))in t ? Object.defineProperty(t, e, {
          value: r,
          enumerable: !0,
          configurable: !0,
          writable: !0
      }) : t[e] = r,
      t
  }
  function j(t, e) {
      for (var r = 0; r < e.length; r++) {
          var o = e[r];
          o.enumerable = o.enumerable || !1,
          o.configurable = !0,
          "value"in o && (o.writable = !0),
          Object.defineProperty(t, S(o.key), o)
      }
  }
  function S(t) {
      var e = function(t, e) {
          if ("object" !== v(t) || null === t)
              return t;
          var r = t[Symbol.toPrimitive];
          if (void 0 !== r) {
              var o = r.call(t, "string");
              if ("object" !== v(o))
                  return o;
              throw new TypeError("@@toPrimitive must return a primitive value.")
          }
          return String(t)
      }(t);
      return "symbol" === v(e) ? e : String(e)
  }
  var x = window.AudioContext || window.webkitAudioContext
    , P = window.AudioWorklet && !(["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend"in document) && !/^((?!chrome|android).)*safari/i.test(navigator.userAgent)
    , O = {
      recordingGain: 1,
      encoderBitRate: 96,
      streaming: !1,
      streamBufferSize: 5e4,
      forceScriptProcessor: !1,
      constraints: {
          channelCount: 1,
          autoGainControl: !0,
          echoCancellation: !0,
          noiseSuppression: !0
      }
  }
    , E = null;
  function N(t) {
      var e = t.getAudioTracks();
      if (e.length < 1)
          throw new Error("No audio tracks in user media stream");
      var r = e[0].getSettings();
      return "channelCount"in r ? r.channelCount : 1
  }
  var A = URL.createObjectURL(new Blob(['\n\tclass AudioOutputProcessor extends AudioWorkletProcessor {\n\t\tprocess(inputs, outputs) {\n\t\t\tthis.port.postMessage(inputs[0]);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tregisterProcessor("audio-output-processor", AudioOutputProcessor);\n'],{
      type: "application/javascript"
  }))
    , C = function() {
      function t(e) {
          !function(t, e) {
              if (!(t instanceof e))
                  throw new TypeError("Cannot call a class as a function")
          }(this, t),
          this.options = w(w({}, O), e),
          this.state = 0,
          this.audioContext = null,
          this.encoder = null,
          this.encodedData = null,
          this.stopPromiseResolve = null,
          this.stopPromiseReject = null,
          this.timer = new d
      }
      var e, r, o, n, i;
      return e = t,
      r = [{
          key: "useAudioWorklet",
          value: function() {
              return P && !this.options.forceScriptProcessor
          }
      }, {
          key: "createAndStartEncoder",
          value: function(t) {
            console.error("createAndStartEncoder" , f)
              var e = this;
              this.encoder = new f({
                  originalSampleRate: this.audioContext.sampleRate,
                  numberOfChannels: t,
                  encoderBitRate: this.options.encoderBitRate,
                  streamBufferSize: this.options.streamBufferSize
              }),
              this.encoder.ondataavailable = function(t) {
                  e.options.streaming ? e.ondataavailable && e.ondataavailable(t) : e.encodedData.push(t)
              }
              ,
              this.encoder.onstopped = function() {
                  e.state = 0;
                  var t = e.options.streaming ? void 0 : new Blob(e.encodedData,{
                      type: "audio/mpeg"
                  });
                  e.onstop && e.onstop(t),
                  e.stopPromiseResolve(t)
              }
              ,
              this.encoder.start()
              console.error("this.encoder ", this.encoder)
          }
      }, {
          key: "createOutputNode",
          value: function(t) {
              var e = this;
              this.useAudioWorklet() ? (console.log("Start Recording"),
              this.outputNode = new AudioWorkletNode(this.audioContext,"audio-output-processor",{
                  numberOfOutputs: 0
              }),
              this.outputNode.port.onmessage = function(t) {
                  var r = t.data;
                  1 == e.state && e.encoder.sendData(r)
              }
              ) : (console.log("Using ScriptProcessorNode"),
              this.outputNode = this.audioContext.createScriptProcessor(4096, t, t),
              this.outputNode.connect(this.audioContext.destination),
              this.outputNode.onaudioprocess = function(t) {
                  if (1 == e.state) {
                      for (var r = t.inputBuffer, o = [], n = 0; n < r.numberOfChannels; n++)
                          o.push(r.getChannelData(n));
                      e.encoder.sendData(o)
                  }
              }
              )
          }
      }, {
          key: "createAudioNodes",
          value: function(t) {
              this.createOutputNode(t),
              this.recordingGainNode = this.audioContext.createGain(),
              this.setRecordingGain(this.options.recordingGain),
              this.recordingGainNode.connect(this.outputNode),
              this.sourceNode = this.audioContext.createMediaStreamSource(this.stream),
              this.sourceNode.connect(this.recordingGainNode)
          }
      }, {
          key: "cleanupAudioNodes",
          value: function() {
              var t;
              this.stream && ((t = this.stream).getTracks ? t.getTracks().forEach((function(t) {
                  return t.stop()
              }
              )) : t.stop(),
              this.stream = null),
              this.useAudioWorklet() ? this.outputNode && (this.outputNode.port.onmessage = null) : this.outputNode && (this.outputNode.onaudioprocess = null),
              this.outputNode && this.outputNode.disconnect(),
              this.recordingGainNode && this.recordingGainNode.disconnect(),
              this.sourceNode && this.sourceNode.disconnect(),
              this.audioContext && this.audioContext.close()
          }
      }, {
          key: "setRecordingGain",
          value: function(t) {
              this.options.recordingGain = t,
              this.recordingGainNode && this.recordingGainNode.gain.setTargetAtTime(t, this.audioContext.currentTime, .01)
          }
      }, {
          key: "time",
          get: function() {
              return this.timer.getTime()
          }
      }, {
          key: "stoppingCheck",
          value: function() {
              if (4 == this.state)
                  throw (t = new Error("AudioRecorder start cancelled by call to stop")).name = "CancelStartError",
                  t;
              var t
          }
      }, {
          key: "__start",
          value: (i = g(y().mark((function t() {
              var e, r, o;
              return y().wrap((function(t) {
                  for (; ; )
                      switch (t.prev = t.next) {
                      case 0:
                          if (0 == this.state) {
                              t.next = 2;
                              break
                          }
                          throw new Error("Called start when not in stopped state");
                      case 2:
                          if (null != E) {
                              t.next = 4;
                              break
                          }
                          throw new Error("preload was not called on AudioRecorder");
                      case 4:
                          return this.state = 3,
                          this.encodedData = [],
                          this.stream = null,
                          t.prev = 7,
                          t.next = 10,
                          f.waitForWorker(E);
                      case 10:
                          return this.stoppingCheck(),
                          e = !(Object.keys(this.options.constraints).length > 0) || this.options.constraints,
                          t.next = 14,
                          navigator.mediaDevices.getUserMedia({
                              audio: e
                          });
                      case 14:
                          if (this.stream = t.sent,
                          this.stoppingCheck(),
                          this.audioContext = new x,
                          !this.useAudioWorklet()) {
                              t.next = 21;
                              break
                          }
                          return t.next = 20,
                          this.audioContext.audioWorklet.addModule(A, {
                              credentials: "omit"
                          });
                      case 20:
                          this.stoppingCheck();
                      case 21:
                          r = N(this.stream),
                          this.createAndStartEncoder(r),
                          this.createAudioNodes(r),
                          this.timer.resetAndStart(),
                          this.state = 1,
                          this.onstart && this.onstart(),
                          t.next = 36;
                          break;
                      case 29:
                          throw t.prev = 29,
                          t.t0 = t.catch(7),
                          o = 4 == this.state,
                          this.cleanupAudioNodes(),
                          this.state = 0,
                          o && this.stopPromiseReject(t.t0),
                          t.t0;
                      case 36:
                      case "end":
                          return t.stop()
                      }
              }
              ), t, this, [[7, 29]])
          }
          ))),
          function() {
              return i.apply(this, arguments)
          }
          )
      }, {
          key: "__stop",
          value: (n = g(y().mark((function t() {
              var e = this;
              return y().wrap((function(t) {
                  for (; ; )
                      switch (t.prev = t.next) {
                      case 0:
                          if (this.timer.stop(),
                          1 != this.state && 2 != this.state) {
                              t.next = 8;
                              break
                          }
                          return this.state = 4,
                          this.cleanupAudioNodes(),
                          this.encoder.stop(),
                          t.abrupt("return", new Promise((function(t, r) {
                              e.stopPromiseResolve = t
                          }
                          )));
                      case 8:
                          if (3 != this.state) {
                              t.next = 11;
                              break
                          }
                          return this.state = 4,
                          t.abrupt("return", new Promise((function(t, r) {
                              e.stopPromiseReject = r
                          }
                          )));
                      case 11:
                          throw new Error("Called stop when AudioRecorder was not started");
                      case 12:
                      case "end":
                          return t.stop()
                      }
              }
              ), t, this)
          }
          ))),
          function() {
              return n.apply(this, arguments)
          }
          )
      }, {
          key: "start",
          value: function() {
              var t = this
                , e = this.__start();
              if (e.catch((function(e) {
                  "CancelStartError" != e.name && t.onerror && t.onerror(e)
              }
              )),
              !this.onerror)
                  return e
          }
      }, {
          key: "stop",
          value: function() {
              var t = this
                , e = this.__stop();
              if (e.catch((function(e) {
                  "CancelStartError" == e.name ? t.onstop && t.onstop(t.options.streaming ? void 0 : null) : t.onerror && t.onerror(e)
              }
              )),
              !this.onerror)
                  return e
          }
      }, {
          key: "pause",
          value: function() {
              1 == this.state && (this.state = 2,
              this.timer.stop())
          }
      }, {
          key: "resume",
          value: function() {
              2 == this.state && (this.state = 1,
              this.timer.start())
          }
      }],
      o = [{
          key: "isRecordingSupported",
          value: function() {
              return x && navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia
          }
      }, {
          key: "preload",
          value: function(t) {
              E = t,
              f.preload(E)
          }
      }],
      r && j(e.prototype, r),
      o && j(e, o),
      Object.defineProperty(e, "prototype", {
          writable: !1
      }),
      t
  }();
  return e.default
}
)()));
