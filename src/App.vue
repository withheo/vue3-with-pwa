<template>
  <div class = "app-wrapper">
    <div class = "app-allow-icon" v-show ="state.useNotificationService">
      <div class = "allow-icon"> <MessageIcon /> </div>
      <div class = "allow-icon"> <NotificationIcon /> </div>
    </div>
    <Login/>
  </div>
</template>

<script lang="ts">
import { defineComponent, onMounted, reactive } from 'vue';
import Login from './components/Login.vue';
import useServerWoker from './composition/useServiceWorker'
import NotificationIcon from './components/icon/NotificationIcon.vue';
import MessageIcon from './components/icon/MessageIcon.vue';

export default defineComponent({
  name: 'App',
  components: {
    Login,
    NotificationIcon,
    MessageIcon
  },
  setup() {

    /**
     * check 해애할 것들
     * serviceWorker 가 되어야 한다는거..
     */
    
    const state = reactive({
      keyStr: "",
      notificationStr : "",
      workerStateStr: "",
      msg: "",
      notiPermission : "",
      workerState: "",
      serviceWorkerState: null as any,
      useNotificationService: false,
    })

    const initWebPushWorker = async () => {
      const { state : serviceWorkerState, init, isGrantedPermission, requestPermission } = useServerWoker();
      state.serviceWorkerState = serviceWorkerState;
      const result = await init();
      if (result === false) {
        alert("모바일에서 APP 알림 기능을 사용할 수 없습니다.")
      } else {
        if (isGrantedPermission() === false) {
          const requestPermissionRes = await requestPermission();
          state.useNotificationService = requestPermissionRes;
        } else {
          state.useNotificationService = true;
        }
      }

      state.serviceWorkerState.notiPermission
    } 

    const onFingerPrint = () => {
      if (!window.PublicKeyCredential) {
        /* Client not capable. Handle error. */
      }

      const publicKey: any = {
        // The challenge is produced by the server; see the Security Considerations
        challenge: new Uint8Array([
          21,
          31,
          105 /* 29 more random bytes generated by the server */
        ]),

        // Relying Party:
        rp: {
          name: "ACME Corporation"
        },

        // User:
        user: {
          id: Uint8Array.from(
            window.atob("MIIBkzCCATigAwIBAjCCAZMwggE4oAMCAQIwggGTMII="),
            c => c.charCodeAt(0)
          ),
          name: "mynet81@gmail.com",
          displayName: "Alex P. Müller"
        },

        // This Relying Party will accept either an ES256 or RS256 credential, but
        // prefers an ES256 credential.
        pubKeyCredParams: [
          {
            type: "public-key",
            alg: -7 // "ES256" as registered in the IANA COSE Algorithms registry
          },
          {
            type: "public-key",
            alg: -257 // Value registered by this specification for "RS256"
          }
        ],

        authenticatorSelection: {
          // Try to use UV if possible. This is also the default.
          userVerification: "preferred"
        },

        timeout: 360000, // 6 minutes
        excludeCredentials: [], // No exclude list of PKCredDescriptors
        extensions: { loc: true } // Include location information
        // in attestation
      };

      // Note: The following call will cause the authenticator to display UI.
      navigator.credentials
        .create({ publicKey })
        // eslint-disable-next-line no-unused-vars
        .then((newCredentialInfo: any) => {
          // Send new credential info to server for verification and registration.
          // eslint-disable-next-line no-unused-vars, no-undef
          
          // eslint-disable-next-line no-undef
          console.log("save", newCredentialInfo);
          state.keyStr = newCredentialInfo;
        })
        .catch(() => {
          // No acceptable authenticator or user refused consent. Handle appropriately.

          console.log("fail");
          state.keyStr = " Fail";
        });
    }

    const onAllowNotification = () => {
      if (!("Notification" in window)) {
        state.notificationStr = "This browser does not support notifications.";
      } 
      Notification.requestPermission().then((result) => {
        state.notificationStr = result;
        if (result === "granted") {
          //randomNotification();
          randomNotification2();
        }
      });
    }
    let msgCnt = 0;
    const randomNotification2 = () => {
      try{
          state.msg = msgCnt + " : 보내기 전2 > ";
          console.log(navigator.serviceWorker);
          navigator.serviceWorker.getRegistrations().then((registration) => {
            setTimeout(() => {
              state.msg = msgCnt + " : 보내기 전3 > ";
              registration[0].showNotification("TEST Notification", {
                body: "Hello",
              });
              state.msg = msgCnt + " : 보내기 완료  > ";
            },3000)
          });
      }catch(e: any) {
        state.msg = msgCnt + " : 보내기 에러 " + e.getMessage();
      }
    }

    // new Notification 모바일에서 X
    // const randomNotification = () => {
    //   try{
    //     const notifTitle = "info";
    //     const options = {
    //       body: "notification Test ",
    //     };
    //     state.msg = msgCnt + " : 보내기 전 > " + options.body;
    //     const notification = new Notification(notifTitle, options);
    //     state.msg = msgCnt + " : 보내기 후 > " + options.body + notification;
    //     // setTimeout(randomNotification, 5000);
    //   }catch(e: any) {
    //     state.msg = msgCnt + " : 보내기 에러 " + e.getMessage();
    //   }
    // }

    onMounted(() => {
      initWebPushWorker();
    })

    return {
      onFingerPrint,
      onAllowNotification,
      state
    }
  }
});
</script>

<style lang="scss">
@import  './scss/index.scss';


*{
  box-sizing: border-box;
  font-family: "Open Sans";
}
body {
  width:100%;
  height:100vh;
  padding:0;
  margin:0;
  background-color: #15002e;
  color: #fff;
}
.wrapper {
  display: flex;
  flex-direction: column;
  width : 100%;
  height: 100%;
  align-items: center;
  justify-content: center;
}
.btn-large {
  width: 200px;
  height: 50px;
  border-radius: 10px;
  cursor: pointer;
  margin-top:4rem;
}
#app {
  width: 100%;
  height:100%;
  padding:0;
  margin:0;
}

.box {
  padding: 10px;
}

.app-allow-icon {
  position: absolute;
  fill:white;
  top: 0px;
  padding-top:1rem;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  width:100%;
  margin-right: 1rem;

  div {
    transition: 0.2s;
    padding: 0.5rem;
    opacity: 0.7;

    &:hover {
      opacity: 1;
    }
  }
}

.app-wrapper {
  display: flex;
  align-items: center;
  justify-content: center;
  width:100%;
  height:100%;
  flex-direction: column;
}
</style>
